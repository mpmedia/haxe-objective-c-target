//
//  PiratePigGame
//  PiratePig
//
//  Source generated by Haxe Objective-C target
//

#import "PiratePigGame.h"

@implementation PiratePigGame

+ (int) NUM_COLUMNS:(int)val {
	static int _val;
	if (val == nil) { if (_val == nil) _val = 8; }
	else { if (_val != nil) _val = val; }
	return _val;
}
+ (int) NUM_ROWS:(int)val {
	static int _val;
	if (val == nil) { if (_val == nil) _val = 8; }
	else { if (_val != nil) _val = val; }
	return _val;
}
+ (NSMutableArray*) tileImages:(NSMutableArray*)val {
	static NSMutableArray *_val;
	if (val == nil) { if (_val == nil) _val = [[NSMutableArray alloc] initWithObjects:[NSMutableString stringWithString:@"game_bear.png"], [NSMutableString stringWithString:@"game_bunny_02.png"], [NSMutableString stringWithString:@"game_carrot.png"], [NSMutableString stringWithString:@"game_lemon.png"], [NSMutableString stringWithString:@"game_panda.png"], [NSMutableString stringWithString:@"game_piratePig.png"], nil]; }
	else { if (_val != nil) _val = val; }
	return _val;
}
@synthesize Background;
@synthesize Logo;
@synthesize Score;
@synthesize TileContainer;
@synthesize currentScale;
@synthesize currentScore;
@synthesize cacheMouse;
@synthesize needToCheckMatches;
@synthesize selectedTile;
@synthesize tiles;
@synthesize usedTiles;
- (void) addTile:(int)row column:(int)column animate:(BOOL)animate{
	// Optional arguments
	if (!animate) animate = YES;
	
	
	NSMutableArray *t = [PiratePigGame tileImages:nil];
	int t2 = [PiratePigGame tileImages:nil].length;
	
	Tile *tile = nil;
	int type = roundf(rand() *  ([PiratePigGame tileImages:nil].length - 1));
	{
		int _g = 0; 
		NSMutableArray *_g1 = self.usedTiles;
		while (_g < _g1.length) {
			
			Tile *usedTile = [_g1 objectAtIndex:_g];
			++_g;
			if (usedTile.removed && usedTile.superview == nil && usedTile.type == type) tile = usedTile;
		}
	}
	if (tile == nil) tile = [[Tile alloc] init:[[PiratePigGame tileImages:nil] objectAtIndex:type]];
	[tile initialize];
	tile.type = type;
	tile.row = row;
	tile.column = column;
	
	NSMutableArray *t1 = [self.tiles objectAtIndex:row];
	[t1 replaceObjectAtIndex:column withObject:tile];
	CGPoint position = [self getPosition:row column:column];
	if (animate) {
		CGPoint firstPosition = [self getPosition:-1 column:column];
		tile.alpha = 0;
		CGRect rect = tile.frame;
		rect.origin.x = firstPosition.x;
		rect.origin.y = firstPosition.y;
		tile.frame = rect;
		[tile moveTo:0.15 *  (row + 1) targetX:position.x targetY:position.y];
	}
	else {
		CGRect rect = tile.frame;
		rect.origin.x = position.x;
		rect.origin.y = position.y;
		tile.frame = rect;
	}
	[self.TileContainer addSubview:tile];
	self.needToCheckMatches = YES;
}
- (void) construct{
	[self addSubview:self.Logo];
	int contentWidth = 75 * [PiratePigGame NUM_COLUMNS:nil];
	CGRect rect = self.Score.frame;
	rect.origin.x = contentWidth - 200;
	rect.origin.y = 12;
	rect.size.width = 200;
	self.Score.frame = rect;
	[self addSubview:self.Score];
	[self addSubview:self.Background];
	CGRect rect1 = self.TileContainer.frame;
	rect1.origin.x = 14;
	rect1.origin.y = 99;
	self.TileContainer.frame = rect1;
	[self addSubview:self.TileContainer];
}
- (void) dropTiles{
	int _g1 = 0; int _g = [PiratePigGame NUM_COLUMNS:nil];
	while (_g1 < _g) {
		int column = _g1++;
		int spaces = 0;
		{
			int _g3 = 0; int _g2 = [PiratePigGame NUM_ROWS:nil];
			while (_g3 < _g2) {
				int row = _g3++;
				int index = [PiratePigGame NUM_ROWS:nil] - 1 - row;
				
				Tile *tile = [[self.tiles objectAtIndex:index] objectAtIndex:column];
				if (tile == nil) spaces++;
				else if (spaces > 0) {
					CGPoint position = [self getPosition:index + spaces column:column];
					[tile moveTo:0.15 * spaces targetX:position.x targetY:position.y];
					tile.row = index + spaces;
					
					NSMutableArray *t = [self.tiles objectAtIndex:index + spaces];
					[t replaceObjectAtIndex:column withObject:tile];
					t = [self.tiles objectAtIndex:index];
					[t replaceObjectAtIndex:column withObject:[NSNull null]];
					self.needToCheckMatches = YES;
				}
			}
		}
		{
			int _g2 = 0;
			while (_g2 < (int)spaces) {
				int i = _g2++;
				int row = spaces - 1 - i;
				[self addTile:row column:column animate:nil];
			}
		}
	}
}
- (NSMutableArray*) findMatches:(BOOL)byRow accumulateScore:(BOOL)accumulateScore{
	// Optional arguments
	if (!accumulateScore) accumulateScore = YES;
	
	
	NSMutableArray *matchedTiles = [[NSMutableArray alloc] init];
	int max;
	int secondMax;
	if (byRow) {
		max = [PiratePigGame NUM_ROWS:nil];
		secondMax = [PiratePigGame NUM_COLUMNS:nil];
	}
	else {
		max = [PiratePigGame NUM_COLUMNS:nil];
		secondMax = [PiratePigGame NUM_ROWS:nil];
	}
	{
		int _g = 0;
		while (_g < max) {
			int index = _g++;
			int matches = 0;
			
			NSMutableArray *foundTiles = [[NSMutableArray alloc] init];
			int previousType = -1;
			{
				int _g1 = 0;
				while (_g1 < secondMax) {
					int secondIndex = _g1++;
					
					Tile *tile;
					if (byRow) {
						
						NSMutableArray *t = [self.tiles objectAtIndex:index];
						tile = [t objectAtIndex:secondIndex];
					}
					else {
						
						NSMutableArray *t = [self.tiles objectAtIndex:secondIndex];
						tile = [t objectAtIndex:index];
					}
					if (tile != nil && !tile.moving) {
						if (previousType == -1) {
							previousType = tile.type;
							[foundTiles push:tile];
							continue;
						}
						else if (tile.type == previousType) {
							[foundTiles push:tile];
							matches++;
						}
					}
					if (tile == nil || tile.moving || tile.type != previousType || secondIndex == secondMax - 1) {
						if (matches >= 2 && previousType != -1) {
							if (accumulateScore) self.currentScore += [Std _int:powf(matches, 2) * 50];
							matchedTiles = [matchedTiles concat:foundTiles];
						}
						matches = 0;
						foundTiles = [[NSMutableArray alloc] init];
						if (tile == nil || tile.moving) {
							self.needToCheckMatches = YES;
							previousType = -1;
						}
						else {
							previousType = tile.type;
							[foundTiles push:tile];
						}
					}
				}
			}
		}
	}
	return matchedTiles;
}
- (CGPoint) getPosition:(int)row column:(int)column{
	return  CGPointMake(column * 73, row * 73);
}
- (void) initialize{
	self.currentScale = 1;
	self.currentScore = 0;
	self.tiles = [[NSMutableArray alloc] init];
	self.usedTiles = [[NSMutableArray alloc] init];
	{
		int _g1 = 0; int _g = [PiratePigGame NUM_ROWS:nil];
		while (_g1 < _g) {
			int row = _g1++;
			[self.tiles replaceObjectAtIndex:row withObject:[[NSMutableArray alloc] init]];
			{
				int _g3 = 0; int _g2 = [PiratePigGame NUM_COLUMNS:nil];
				while (_g3 < _g2) {
					int column = _g3++;
					
					NSMutableArray *t = [self.tiles objectAtIndex:row];
					[t replaceObjectAtIndex:column withObject:[NSNull null]];
				}
			}
		}
	}
	self.Background = [[UIView alloc] init];
	self.Logo = [[[UIImageView alloc] init] initWithImage:[UIImage imageNamed:[NSMutableString stringWithString:@"logo.png"]]];
	self.Score = [[UILabel alloc] init];
	self.Score.frame = CGRectMake (0,0,100,50);
	self.Score.textColor = [UIColor yellowColor];
	self.Score.backgroundColor = [UIColor clearColor];
	self.Score.textAlignment =  NSTextAlignmentLeft;
	self.Score.font = [UIFont boldSystemFontOfSize:30];
	self.TileContainer = [[UIView alloc] init];
}
- (void) newGame{
	self.currentScore = 0;
	self.Score.text = [NSMutableString stringWithString:@"0"];
	{
		int _g1 = 0; int _g = [PiratePigGame NUM_ROWS:nil];
		while (_g1 < _g) {
			int row = _g1++;
			{
				int _g3 = 0; int _g2 = [PiratePigGame NUM_COLUMNS:nil];
				while (_g3 < _g2) {
					int column = _g3++;
					[self removeTile:row column:column animate:NO];
				}
			}
		}
	}
	{
		int _g1 = 0; int _g = [PiratePigGame NUM_ROWS:nil];
		while (_g1 < _g) {
			int row = _g1++;
			{
				int _g3 = 0; int _g2 = [PiratePigGame NUM_COLUMNS:nil];
				while (_g3 < _g2) {
					int column = _g3++;
					[self addTile:row column:column animate:NO];
				}
			}
		}
	}
}
- (void) removeTile:(int)row column:(int)column animate:(BOOL)animate{
	// Optional arguments
	if (!animate) animate = YES;
	
	
	NSMutableArray *t = [self.tiles objectAtIndex:row];
	
	Tile *tile = [t objectAtIndex:column];
	if (tile != nil) {
		[tile remove:animate];
		[self.usedTiles push:tile];
	}
	
	NSMutableArray *t1 = [self.tiles objectAtIndex:row];
	[t1 replaceObjectAtIndex:column withObject:[NSNull null]];
}
- (void) resize:(int)newWidth newHeight:(int)newHeight{
	float maxWidth = newWidth * 0.90;
	float maxHeight = newHeight * 0.86;
	self.currentScale = 1;
	float currentWidth = self.frame.size.width;
	float currentHeight = self.frame.size.height;
	if (currentWidth > maxWidth || currentHeight > maxHeight) {
		float maxScaleX = maxWidth / currentWidth;
		float maxScaleY = maxHeight / currentHeight;
		if (maxScaleX < maxScaleY) self.currentScale = maxScaleX;
		else self.currentScale = maxScaleY;
	}
	CGRect rect = self.frame;
	rect.origin.x = newWidth / 2 - currentWidth * self.currentScale / 2;
	self.frame = rect;
}
- (void) swapTile:(Tile*)tile targetRow:(int)targetRow targetColumn:(int)targetColumn{
	if (targetColumn >= 0 && targetColumn < [PiratePigGame NUM_COLUMNS:nil] && targetRow >= 0 && targetRow < [PiratePigGame NUM_ROWS:nil]) {
		
		Tile *targetTile = [[self.tiles objectAtIndex:targetRow] objectAtIndex:targetColumn];
		if (targetTile != nil && !targetTile.moving) {
			
			NSMutableArray *t = [self.tiles objectAtIndex:targetRow];
			[t replaceObjectAtIndex:targetColumn withObject:tile];
			t = [self.tiles objectAtIndex:tile.row];
			[t replaceObjectAtIndex:tile.column withObject:targetTile];
			if ([self findMatches:YES accumulateScore:NO].length > 0 || [self findMatches:NO accumulateScore:NO].length > 0) {
				targetTile.row = tile.row;
				targetTile.column = tile.column;
				tile.row = targetRow;
				tile.column = targetColumn;
				CGPoint targetTilePosition = [self getPosition:targetTile.row column:targetTile.column];
				CGPoint tilePosition = [self getPosition:tile.row column:tile.column];
				[targetTile moveTo:0.3 targetX:targetTilePosition.x targetY:targetTilePosition.y];
				[tile moveTo:0.3 targetX:tilePosition.x targetY:tilePosition.y];
				self.needToCheckMatches = YES;
			}
			else {
				
				NSMutableArray *t1 = [self.tiles objectAtIndex:targetRow];
				[t1 replaceObjectAtIndex:targetColumn withObject:targetTile];
				t1 = [self.tiles objectAtIndex:tile.row];
				[t1 replaceObjectAtIndex:tile.column withObject:tile];
			}
		}
	}
}
- (void) touchesBegan:(NSSet*)touches withEvent:(UIEvent*)withEvent{
	
	NSSet *touchesForView = [withEvent touchesForView:self];
	id anyObject = [touches anyObject];
}
- (void) touchesMoved:(NSSet*)touches withEvent:(UIEvent*)withEvent{
}
- (void) touchesEnded:(NSSet*)touches withEvent:(UIEvent*)withEvent{
	if (self.cacheMouse != nil && self.selectedTile != nil && !self.selectedTile.moving) {
		int differenceX = 0;
		int differenceY = 0;
		if (fabsf(differenceX) > 10 || fabsf(differenceY) > 10) {
			int swapToRow = self.selectedTile.row;
			int swapToColumn = self.selectedTile.column;
			if (fabsf(differenceX) > fabsf(differenceY)) {
				if (differenceX < 0) swapToColumn--;
				else swapToColumn++;
			}
			else if (differenceY < 0) swapToRow--;
			else swapToRow++;
			[self swapTile:self.selectedTile targetRow:swapToRow targetColumn:swapToColumn];
		}
	}
	self.selectedTile = nil;
	self.cacheMouse = nil;
}
- (void) touchesCancelled:(NSSet*)touches withEvent:(UIEvent*)withEvent{
}
- (void) loop{
	if (self.needToCheckMatches) {
		
		NSMutableArray *matchedTiles = [[NSMutableArray alloc] init];
		matchedTiles = [matchedTiles concat:[self findMatches:YES accumulateScore:nil]];
		matchedTiles = [matchedTiles concat:[self findMatches:NO accumulateScore:nil]];
		{
			int _g = 0;
			while (_g < matchedTiles.length) {
				
				Tile *tile = [matchedTiles objectAtIndex:_g];
				++_g;
				[self removeTile:tile.row column:tile.column animate:nil];
			}
		}
		if (matchedTiles.length > 0) {
			self.Score.text = [Std string:self.currentScore];
			[self dropTiles];
		}
	}
}
- (id) init{
	self = [super init];
	[self initialize];
	[self construct];
	[self newGame];
	return self;
}

@end
