//
//  Json
//  Tests
//
//  Source generated by Haxe Objective-C target
//

#import "../haxe/Json.h"

@implementation Json

+ (id) parse:(NSMutableString*)text{
	return [[[Json alloc] init].doParse:text];
}
+ (NSMutableString*) stringify:(id)value replacer:(SEL)replacer{
	// Optional arguments
	if (!replacer) replacer = nil;
	
	return [[[Json alloc] init].toString:value replacer:replacer];
}
@synthesize buf;
@synthesize str;
@synthesize pos;

- (NSMutableString*) toString:(id)v replacer:(SEL)replacer{
	// Optional arguments
	if (!replacer) replacer = nil;
	
	self.buf = [[StringBuf alloc] init];
	self.replacer = replacer;
	[self toStringRec:[NSMutableString stringWithString:@""] v:v];
	return self.buf.b;
}
- (void) fieldsString:(id)v fields:(NSMutableArray*)fields{
	BOOL first = YES;
	[self.buf.b appendString:[NSMutableString stringWithString:@"{"]];
	{
		int _g = 0;
		while (_g < fields.length) {
			
			NSMutableString *f = [fields objectAtIndex:_g];
			++_g;
			id value = [Reflect field:v field:f];
			if ([Reflect isFunction:value]) continue;
			if (first) first = NO;
			else [self.buf.b appendString:[NSMutableString stringWithString:@","]];
			[self quote:f];
			[self.buf.b appendString:[NSMutableString stringWithString:@":"]];
			[self toStringRec:f v:value];
		}
	}
	[self.buf.b appendString:[NSMutableString stringWithString:@"}"]];
}
- (void) objString:(id)v{
	[self fieldsString:v fields:[Reflect fields:v]];
}
- (void) toStringRec:(id)k v:(id)v{
	if (self.replacer != nil) v = [self replacer:k :v];
	{
		
		Type *_g = [Type _typeof:v];
		
		var $e : enum =  (_g)
		switch ( $e.index ) {
			
			case 8:
			{
				[self.buf.b appendString:[NSMutableString stringWithString:@"\"???\""]]}break
			case 4:
			{
				[self objString:v]}break
			case 1:
			{
				{
					
					NSMutableString *v1 = v;
					self.buf.b += [Std string:v1];
				}}break
			case 2:
			{
				self.buf.b += [Std string:( (isfinite(v)) ? v : [NSMutableString stringWithString:@"null"])]}break
			case 5:
			{
				[self.buf.b appendString:[NSMutableString stringWithString:@"\"<fun>\""]]}break
			case 6:
			
			var MATCH _g_eTClass_0 : Class = $e.params[0]{
				if (_g_eTClass_0 == NSMutableString) [self quote:v];
				else if (_g_eTClass_0 == NSMutableArray) {
					
					NSMutableArray *v1 = v;
					[self.buf.b appendString:[NSMutableString stringWithString:@"["]];
					int len = v1.length;
					if (len > 0) {
						[self toStringRec:0 v:[v1 objectAtIndex:0]];
						int i = 1;
						while (i < len) {
							[self.buf.b appendString:[NSMutableString stringWithString:@","]];
							[self toStringRec:i v:[v1 objectAtIndex:i++]];
						}
					}
					[self.buf.b appendString:[NSMutableString stringWithString:@"]"]];
				}
				else if (_g_eTClass_0 == StringMap) {
					
					StringMap *v1 = v;
					id o = struct {
					
					} structName;
					{
						id _it2 = [v1 keys];
						while ( [_it2 hasNext] ) do {
							NSMutableString k1 = [_it2 next];
							if (o != nil) [o __SetField-TDynamic-];
						}
					}
					[self objString:o];
				}
				else [self objString:v]}break
			case 7:
			{
				{
					id i = ((int)($this:(snd ctx.path)) 
					EnumValue *e = v
					__r__3 = [e __Index]
					return __r__3{
						
						int* __r__3}
					}(self));
					{
						
						NSMutableString *v1 = i;
						self.buf.b += [Std string:v1];
					}
				}}break
			case 3:
			{
				{
					
					NSMutableString *v1 = v;
					self.buf.b += [Std string:v1];
				}}break
			case 0:
			{
				[self.buf.b appendString:[NSMutableString stringWithString:@"null"]]}break
		}
	}
}
- (void) quote:(NSMutableString*)s{
	[self.buf.b appendString:[NSMutableString stringWithString:@"\""]];
	int i = 0;
	while (YES) {
		int c = [s characterAtIndex:i++];
		if (c == -1) break;
		switch (c){
			case 34:{
				[self.buf.b appendString:[NSMutableString stringWithString:@"\\\""]]}break;
			case 92:{
				[self.buf.b appendString:[NSMutableString stringWithString:@"\\\\"]]}break;
			case 10:{
				[self.buf.b appendString:[NSMutableString stringWithString:@"\\n"]]}break;
			case 13:{
				[self.buf.b appendString:[NSMutableString stringWithString:@"\\r"]]}break;
			case 9:{
				[self.buf.b appendString:[NSMutableString stringWithString:@"\\t"]]}break;
			case 8:{
				[self.buf.b appendString:[NSMutableString stringWithString:@"\\b"]]}break;
			case 12:{
				[self.buf.b appendString:[NSMutableString stringWithString:@"\\f"]]}break;
			default:{
				self.buf.b += [NSMutableString:c]}break;
		}
	}
	[self.buf.b appendString:[NSMutableString stringWithString:@"\""]];
}
- (id) doParse:(NSMutableString*)str{
	self.str = str;
	self.pos = 0;
	return [self parseRec];
}
- (void) invalidChar{
	self.pos--;
	@throw [[[[NSMutableString stringWithString:@"Invalid char "] stringByAppendingString:[self.str characterAtIndex:self.pos]] stringByAppendingString:[NSMutableString stringWithString:@" at position "]] stringByAppendingString:self.pos];;
}
- (int) nextChar{
	return [self.str characterAtIndex:self.pos++];
}
- (id) parseRec{
	while (YES) {
		int c = [self.str characterAtIndex:self.pos++];
		switch (c){
			case 32:case 13:case 10:case 9:{
				break;
				case 123:{
					{
						id obj = struct {
						
						} structName; 
						NSMutableString *field = nil; BOOL comma = nil;
						while (YES) {
							int c1 = [self.str characterAtIndex:self.pos++];
							switch (c1){
								case 32:case 13:case 10:case 9:{
									break;
									case 125:{
										{
											if (field != nil || comma == NO) [self invalidChar];
											return obj;
										}}break;
									case 58:{
										{
											if (field == nil) [self invalidChar];
											if (obj != nil) [obj __SetField-TDynamic-];
											field = nil;
											comma = YES;
										}}break;
									case 44:{
										if (comma) comma = NO;
										else [self invalidChar]}break;
									case 34:{
										{
											if (comma) [self invalidChar];
											field = [self parseString];
										}}break;
									default:{
										[self invalidChar]}break;
								}
							}
						}}break;
					case 91:{
						{
							
							NSMutableArray *arr = [[NSMutableArray alloc] initWithObjects:, nil]; BOOL comma = nil;
							while (YES) {
								int c1 = [self.str characterAtIndex:self.pos++];
								switch (c1){
									case 32:case 13:case 10:case 9:{
										break;
										case 93:{
											{
												if (comma == NO) [self invalidChar];
												return arr;
											}}break;
										case 44:{
											if (comma) comma = NO;
											else [self invalidChar]}break;
										default:{
											{
												if (comma) [self invalidChar];
												self.pos--;
												[arr push:[self parseRec]];
												comma = YES;
											}}break;
									}
								}
							}}break;
						case 116:{
							{
								int save = self.pos;
								if ([self.str characterAtIndex:self.pos++] != 114 || [self.str characterAtIndex:self.pos++] != 117 || [self.str characterAtIndex:self.pos++] != 101) {
									self.pos = save;
									[self invalidChar];
								}
								return YES;
							}}break;
						case 102:{
							{
								int save = self.pos;
								if ([self.str characterAtIndex:self.pos++] != 97 || [self.str characterAtIndex:self.pos++] != 108 || [self.str characterAtIndex:self.pos++] != 115 || [self.str characterAtIndex:self.pos++] != 101) {
									self.pos = save;
									[self invalidChar];
								}
								return NO;
							}}break;
						case 110:{
							{
								int save = self.pos;
								if ([self.str characterAtIndex:self.pos++] != 117 || [self.str characterAtIndex:self.pos++] != 108 || [self.str characterAtIndex:self.pos++] != 108) {
									self.pos = save;
									[self invalidChar];
								}
								return nil;
							}}break;
						case 34:{
							return [self parseString]}break;
						case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:case 45:{
							return ((float)($this:(snd ctx.path)) int c1 = c
							int start = self.pos - 1
							BOOL minus = c1 == 45; BOOL digit = !minus; BOOL zero = c1 == 48
							BOOL point = NO; BOOL e = NO; BOOL pm = NO; BOOL end = NO
							while (YES) {
								c1 = [self.str characterAtIndex:self.pos++];
								switch (c1){
									case 48:{
										{
											if (zero && !point) [self invalidNumber:start];
											if (minus) {
												minus = NO;
												zero = YES;
											}
											digit = YES;
										}}break;
									case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:{
										{
											if (zero && !point) [self invalidNumber:start];
											if (minus) minus = NO;
											digit = YES;
											zero = NO;
										}}break;
									case 46:{
										{
											if (minus || point) [self invalidNumber:start];
											digit = NO;
											point = YES;
										}}break;
									case 101:case 69:{
										{
											if (minus || zero || e) [self invalidNumber:start];
											digit = NO;
											e = YES;
										}}break;
									case 43:case 45:{
										{
											if (!e || pm) [self invalidNumber:start];
											digit = NO;
											pm = YES;
										}}break;
									default:{
										{
											if (!digit) [self invalidNumber:start];
											self.pos--;
											end = YES;
										}}break;
								}
								if (end) break;
							}
							float f = [Std parseFloat:[self.str substr:start len:self.pos - start]]
							int i = [Std _int:f]
							__r__ = ( (i == f) ? i : f)
							return __r__{
								
								float* __r__}
							}(self))}break;
						default:{
							[self invalidChar]}break;
					}
				}
				return nil;
			}
			- (NSMutableString*) parseString{
				int start = self.pos;
				
				StringBuf *buf = [[StringBuf alloc] init];
				while (YES) {
					int c = [self.str characterAtIndex:self.pos++];
					if (c == 34) break;
					if (c == 92) {
						{
							
							NSMutableString *s = self.str; int len = self.pos - start - 1;
							buf.b += ( (len == nil) ? [s substr:start len:nil] : [s substr:start len:len]);
						}
						c = [self.str characterAtIndex:self.pos++];
						switch (c){
							case 114:{
								[buf.b appendString:[NSMutableString stringWithString:@"\r"]]}break;
							case 110:{
								[buf.b appendString:[NSMutableString stringWithString:@"\n"]]}break;
							case 116:{
								[buf.b appendString:[NSMutableString stringWithString:@"\t"]]}break;
							case 98:{
								[buf.b appendString:[NSMutableString stringWithString:@""]]}break;
							case 102:{
								[buf.b appendString:[NSMutableString stringWithString:@""]]}break;
							case 47:case 92:case 34:{
								buf.b += [NSMutableString:c]}break;
							case 117:{
								{
									int uc = [Std parseInt:[[NSMutableString stringWithString:@"0x"] stringByAppendingString:[self.str substr:self.pos len:@"4"]]];
									self.pos += 4;
									buf.b += [NSMutableString:uc];
								}}break;
							default:{
								@throw [[[[NSMutableString stringWithString:@"Invalid escape sequence \\"] stringByAppendingString:[NSMutableString:c]] stringByAppendingString:[NSMutableString stringWithString:@" at position "]] stringByAppendingString: (self.pos - @"1")];}break;
						}
						start = self.pos;
					}
					else if (c == -1) @throw [NSMutableString stringWithString:@"Unclosed string"];;
				}
				{
					
					NSMutableString *s = self.str; int len = self.pos - start - 1;
					buf.b += ( (len == nil) ? [s substr:start len:nil] : [s substr:start len:len]);
				}
				return buf.b;
			}
			- (void) invalidNumber:(int)start{
				@throw [[[[NSMutableString stringWithString:@"Invalid number at position "] stringByAppendingString:start] stringByAppendingString:[NSMutableString stringWithString:@": "]] stringByAppendingString:[self.str substr:start len:self.pos - start]];;
			}
			- (float) parseNumber:(int)c{
				int start = self.pos - 1;
				BOOL minus = c == 45; BOOL digit = !minus; BOOL zero = c == 48;
				BOOL point = NO; BOOL e = NO; BOOL pm = NO; BOOL end = NO;
				while (YES) {
					c = [self.str characterAtIndex:self.pos++];
					switch (c){
						case 48:{
							{
								if (zero && !point) [self invalidNumber:start];
								if (minus) {
									minus = NO;
									zero = YES;
								}
								digit = YES;
							}}break;
						case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:{
							{
								if (zero && !point) [self invalidNumber:start];
								if (minus) minus = NO;
								digit = YES;
								zero = NO;
							}}break;
						case 46:{
							{
								if (minus || point) [self invalidNumber:start];
								digit = NO;
								point = YES;
							}}break;
						case 101:case 69:{
							{
								if (minus || zero || e) [self invalidNumber:start];
								digit = NO;
								e = YES;
							}}break;
						case 43:case 45:{
							{
								if (!e || pm) [self invalidNumber:start];
								digit = NO;
								pm = YES;
							}}break;
						default:{
							{
								if (!digit) [self invalidNumber:start];
								self.pos--;
								end = YES;
							}}break;
					}
					if (end) break;
				}
				float f = [Std parseFloat:[self.str substr:start len:self.pos - start]];
				int i = [Std _int:f];
				return ( (i == f) ? i : f);
			}
			- (id) init{
				self = [super init];
				return self;
			}

@end
